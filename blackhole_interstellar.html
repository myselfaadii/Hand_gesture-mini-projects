<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Black Hole — Interactive 360 (FIXED)</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Inter,Arial,Helvetica,sans-serif}
  #container{width:100%;height:100%;position:relative}
  #video{position:absolute;right:14px;bottom:14px;width:220px;height:165px;border-radius:10px;transform:scaleX(-1);z-index:20;box-shadow:0 14px 50px rgba(0,0,0,0.7)}
  #hud{position:absolute;left:18px;top:18px;color:#f0f8ff;z-index:30}
  #hud .title{font-weight:800;font-size:18px}
  #hud .hint{opacity:0.9;margin-top:6px}
  #cal{margin-top:10px;padding:8px 10px;border-radius:8px;background:linear-gradient(90deg,#7dd3fc,#60a5fa);color:#012;border:none;font-weight:700;cursor:pointer}
</style>
</head>
<body>
<div id="container"></div>
<video id="video" autoplay playsinline muted></video>
<div id="hud">
  <div class="title">Black Hole — Interactive 360</div>
  <div class="hint">Move hand to orbit · Pinch to zoom · Rotate palm to spin disk</div>
  <button id="cal">Calibrate</button>
</div>

<script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* =====================================================
   BLACK HOLE — FIXED VERSION
   Reason previous was blank:
   - Postprocessing orthographic camera was undefined
   - Now simplified pipeline (no RT) + stable shaders
===================================================== */

// ---------------- Renderer & Scene ----------------
const container = document.getElementById('container');
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000005);

// ---------------- Camera ----------------
const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.01, 1000);
let cam = {r:38, theta:0.4, phi:1.1};
let target = new THREE.Vector3(0,0,0);

// ---------------- Lights ----------------
scene.add(new THREE.AmbientLight(0x333366,0.4));
const coreLight = new THREE.PointLight(0xffffff,2.5,0,2);
scene.add(coreLight);

// ---------------- Starfield ----------------
function makeStars(n=10000){
  const g=new THREE.BufferGeometry();
  const p=new Float32Array(n*3);
  for(let i=0;i<n;i++){
    const r=Math.random()*800;
    const t=Math.random()*Math.PI*2;
    const u=Math.acos(2*Math.random()-1);
    p[i*3]=r*Math.sin(u)*Math.cos(t);
    p[i*3+1]=r*Math.sin(u)*Math.sin(t);
    p[i*3+2]=r*Math.cos(u);
  }
  g.setAttribute('position',new THREE.BufferAttribute(p,3));
  return new THREE.Points(g,new THREE.PointsMaterial({size:0.7,color:0x88bbff}));
}
scene.add(makeStars());

// ---------------- Event Horizon ----------------
const horizon = new THREE.Mesh(
  new THREE.SphereGeometry(3,64,64),
  new THREE.MeshBasicMaterial({color:0x000000})
);
scene.add(horizon);

// ---------------- Photon Ring ----------------
const ring = new THREE.Mesh(
  new THREE.RingGeometry(3.4,3.9,256),
  new THREE.MeshBasicMaterial({color:0xffe5aa,transparent:true,opacity:0.9,side:THREE.DoubleSide})
);
ring.rotation.x=Math.PI/2;
scene.add(ring);

// ---------------- Accretion Disk (Shader) ----------------
const diskGeo = new THREE.TorusGeometry(11,2.8,128,512);
const diskMat = new THREE.ShaderMaterial({
  transparent:true,
  side:THREE.DoubleSide,
  uniforms:{time:{value:0}},
  vertexShader:`varying vec2 vUv; void main(){vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
  fragmentShader:`
    varying vec2 vUv; uniform float time;
    void main(){
      float a = vUv.x*6.283;
      float r = abs(vUv.y-0.5);
      float glow = exp(-r*10.0);
      float dop = sin(a + time*1.5);
      vec3 col = mix(vec3(1.0,0.6,0.3), vec3(0.5,0.7,1.0), dop*0.5+0.5);
      col *= glow*2.0;
      gl_FragColor = vec4(col, glow);
    }`
});
const disk = new THREE.Mesh(diskGeo,diskMat);
disk.rotation.x=Math.PI/2;
scene.add(disk);

// ---------------- MediaPipe Hands ----------------
const video=document.getElementById('video');
let hand=null, pinch=0.08, basePinch=null, palmAngle=0;

const hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({maxNumHands:1,modelComplexity:1,minDetectionConfidence:0.6,minTrackingConfidence:0.6});
hands.onResults(r=>{
  if(r.multiHandLandmarks&&r.multiHandLandmarks.length){
    const lm=r.multiHandLandmarks[0];
    hand={x:(lm[0].x+lm[9].x)/2,y:(lm[0].y+lm[9].y)/2};
    pinch=Math.hypot(lm[4].x-lm[8].x,lm[4].y-lm[8].y);
    palmAngle=Math.atan2(lm[9].y-lm[0].y,lm[9].x-lm[0].x);
  } else hand=null;
});
new Camera(video,{onFrame:async()=>{await hands.send({image:video});},width:640,height:480}).start();

document.getElementById('cal').onclick=()=>{basePinch=pinch; alert('Calibrated');};

// ---------------- Animation Loop ----------------
let last=performance.now();
function animate(){
  requestAnimationFrame(animate);
  const now=performance.now(); const dt=(now-last)/1000; last=now;

  diskMat.uniforms.time.value+=dt;
  ring.rotation.z+=0.3*dt;

  if(hand){
    const hx=(0.5-hand.x)*2;
    const hy=(hand.y-0.5)*1.6;
    cam.theta+=hx*0.03;
    cam.phi=THREE.MathUtils.clamp(cam.phi+hy*0.03,0.2,Math.PI-0.2);
    if(basePinch===null) basePinch=pinch;
    cam.r=THREE.MathUtils.clamp(cam.r+(basePinch-pinch)*60,8,120);
    disk.rotation.z+=palmAngle*0.02;
  } else {
    cam.theta+=0.002;
  }

  const x=cam.r*Math.sin(cam.phi)*Math.cos(cam.theta);
  const y=cam.r*Math.cos(cam.phi);
  const z=cam.r*Math.sin(cam.phi)*Math.sin(cam.theta);
  camera.position.set(x,y,z);
  camera.lookAt(target);

  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
